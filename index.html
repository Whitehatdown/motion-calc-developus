<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Motion Tracker</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        #videoElement {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        #stats {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 3;
            max-width: 300px;
        }
        #startBtn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 4;
            padding: 12px 24px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 18px;
            cursor: pointer;
        }
        #startBtn:hover {
            background-color: #45a049;
        }
        #originPoint {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 3;
        }
        #currentPoint {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: blue;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 3;
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="videoElement" autoplay playsinline></video>
        <div id="overlay">
            <div id="originPoint"></div>
            <div id="currentPoint"></div>
        </div>
        <div id="stats">
            <h3>Motion Data</h3>
            <div id="accelerometer">Accelerometer: waiting...</div>
            <div id="gyroscope">Gyroscope: waiting...</div>
            <div id="orientation">Orientation: waiting...</div>
            <div id="position">Position: (0, 0, 0)</div>
            <div id="velocity">Velocity: (0, 0, 0)</div>
            <div id="distance">Distance from origin: 0m</div>
        </div>
        <button id="startBtn">Start Tracking</button>
    </div>

    <script>
        // DOM elements
        const videoElement = document.getElementById('videoElement');
        const startBtn = document.getElementById('startBtn');
        const accelerometerDisplay = document.getElementById('accelerometer');
        const gyroscopeDisplay = document.getElementById('gyroscope');
        const orientationDisplay = document.getElementById('orientation');
        const positionDisplay = document.getElementById('position');
        const velocityDisplay = document.getElementById('velocity');
        const distanceDisplay = document.getElementById('distance');
        const originPoint = document.getElementById('originPoint');
        const currentPoint = document.getElementById('currentPoint');

        // State variables
        let initializing = true;
        let tracking = false;
        let originX = 0, originY = 0, originZ = 0;
        let currentX = 0, currentY = 0, currentZ = 0;
        let velocityX = 0, velocityY = 0, velocityZ = 0;
        let lastTimestamp = 0;
        let alpha = 0, beta = 0, gamma = 0;
        let accX = 0, accY = 0, accZ = 0;
        let gyroX = 0, gyroY = 0, gyroZ = 0;

        // Positioning calculation constants
        const GRAVITY = 9.81; // m/s²
        const DAMPING = 0.85; // Damping factor to reduce drift
        const ACC_THRESHOLD = 0.1; // Threshold to ignore small accelerations (m/s²)

        // Camera setup
        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "environment" },
                    audio: false 
                });
                videoElement.srcObject = stream;
                return true;
            } catch (error) {
                console.error('Error accessing camera:', error);
                alert('Camera access denied or not available. Please allow camera access and try again.');
                return false;
            }
        }

        // Initialize sensors
        function setupSensors() {
            // Check if DeviceMotionEvent is available
            if (window.DeviceMotionEvent) {
                // Check if permission is needed (iOS 13+)
                if (typeof DeviceMotionEvent.requestPermission === 'function') {
                    DeviceMotionEvent.requestPermission()
                        .then(response => {
                            if (response === 'granted') {
                                window.addEventListener('devicemotion', handleMotion);
                            } else {
                                alert('Motion sensor access denied. Please allow sensor access and try again.');
                            }
                        })
                        .catch(console.error);
                } else {
                    // For non-iOS devices or older iOS versions
                    window.addEventListener('devicemotion', handleMotion);
                }
            } else {
                alert('Motion sensors not available on this device.');
                accelerometerDisplay.textContent = 'Accelerometer: Not available';
            }

            // Check if DeviceOrientationEvent is available
            if (window.DeviceOrientationEvent) {
                // Check if permission is needed (iOS 13+)
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission()
                        .then(response => {
                            if (response === 'granted') {
                                window.addEventListener('deviceorientation', handleOrientation);
                            } else {
                                alert('Orientation sensor access denied. Please allow sensor access and try again.');
                            }
                        })
                        .catch(console.error);
                } else {
                    // For non-iOS devices or older iOS versions
                    window.addEventListener('deviceorientation', handleOrientation);
                }
            } else {
                alert('Orientation sensors not available on this device.');
                gyroscopeDisplay.textContent = 'Gyroscope: Not available';
                orientationDisplay.textContent = 'Orientation: Not available';
            }
        }

        // Handle motion sensor data
        function handleMotion(event) {
            // Get acceleration data (including gravity)
            accX = event.accelerationIncludingGravity.x;
            accY = event.accelerationIncludingGravity.y;
            accZ = event.accelerationIncludingGravity.z;
            
            // Get raw acceleration data (without gravity, if available)
            const rawAccX = event.acceleration?.x || 0;
            const rawAccY = event.acceleration?.y || 0;
            const rawAccZ = event.acceleration?.z || 0;
            
            // Get rotation rate data
            gyroX = event.rotationRate?.alpha || 0;
            gyroY = event.rotationRate?.beta || 0;
            gyroZ = event.rotationRate?.gamma || 0;
            
            // Update display
            accelerometerDisplay.textContent = `Accelerometer: 
                X: ${accX.toFixed(2)}, 
                Y: ${accY.toFixed(2)}, 
                Z: ${accZ.toFixed(2)}`;
            
            gyroscopeDisplay.textContent = `Gyroscope: 
                X: ${gyroX.toFixed(2)}, 
                Y: ${gyroY.toFixed(2)}, 
                Z: ${gyroZ.toFixed(2)}`;
            
            // Use acceleration to calculate position when tracking
            if (tracking) {
                const now = performance.now();
                const dt = (now - lastTimestamp) / 1000; // Convert to seconds
                lastTimestamp = now;
                
                if (dt > 0 && dt < 1) { // Ignore unreasonable time deltas
                    // Remove gravity component based on orientation
                    let adjustedAccX = rawAccX || (accX - (GRAVITY * Math.sin(beta * Math.PI / 180)));
                    let adjustedAccY = rawAccY || (accY - (GRAVITY * Math.sin(gamma * Math.PI / 180)));
                    let adjustedAccZ = rawAccZ || (accZ - (GRAVITY * Math.cos(beta * Math.PI / 180)));
                    
                    // Apply threshold to reduce noise
                    adjustedAccX = Math.abs(adjustedAccX) > ACC_THRESHOLD ? adjustedAccX : 0;
                    adjustedAccY = Math.abs(adjustedAccY) > ACC_THRESHOLD ? adjustedAccY : 0;
                    adjustedAccZ = Math.abs(adjustedAccZ) > ACC_THRESHOLD ? adjustedAccZ : 0;
                    
                    // Apply orientation correction
                    const orientationCorrectedAccX = adjustedAccX;
                    const orientationCorrectedAccY = adjustedAccY;
                    const orientationCorrectedAccZ = adjustedAccZ;
                    
                    // Update velocity with acceleration (v = v0 + a*t)
                    velocityX = (velocityX + orientationCorrectedAccX * dt) * DAMPING;
                    velocityY = (velocityY + orientationCorrectedAccY * dt) * DAMPING;
                    velocityZ = (velocityZ + orientationCorrectedAccZ * dt) * DAMPING;
                    
                    // Update position with velocity (p = p0 + v*t)
                    currentX += velocityX * dt;
                    currentY += velocityY * dt;
                    currentZ += velocityZ * dt;
                    
                    // Update displays
                    updatePositionDisplay();
                }
            }
        }

        // Handle orientation sensor data
        function handleOrientation(event) {
            // Get orientation data
            alpha = event.alpha || 0; // Z-axis rotation [0, 360)
            beta = event.beta || 0;   // X-axis rotation [-180, 180]
            gamma = event.gamma || 0; // Y-axis rotation [-90, 90]
            
            // Update display
            orientationDisplay.textContent = `Orientation: 
                α: ${alpha.toFixed(2)}°, 
                β: ${beta.toFixed(2)}°, 
                γ: ${gamma.toFixed(2)}°`;
        }

        // Update position display and visual indicator
        function updatePositionDisplay() {
            // Calculate distance from origin
            const deltaX = currentX - originX;
            const deltaY = currentY - originY;
            const deltaZ = currentZ - originZ;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ);
            
            // Update text displays
            positionDisplay.textContent = `Position: (${currentX.toFixed(2)}, ${currentY.toFixed(2)}, ${currentZ.toFixed(2)})`;
            velocityDisplay.textContent = `Velocity: (${velocityX.toFixed(2)}, ${velocityY.toFixed(2)}, ${velocityZ.toFixed(2)})`;
            distanceDisplay.textContent = `Distance from origin: ${distance.toFixed(2)}m`;
            
            // Update visual position indicators (2D projection on screen)
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            
            // Origin point (center)
            originPoint.style.left = `${screenWidth / 2}px`;
            originPoint.style.top = `${screenHeight / 2}px`;
            
            // Current point (moves relative to origin)
            // Scale factor to make movement visible on screen
            const scaleFactor = 50;
            const currentPointX = (screenWidth / 2) + (deltaX * scaleFactor);
            const currentPointY = (screenHeight / 2) + (deltaY * scaleFactor);
            
            currentPoint.style.left = `${currentPointX}px`;
            currentPoint.style.top = `${currentPointY}px`;
        }

        // Start tracking
        function startTracking() {
            // Hide the start button
            startBtn.style.display = 'none';
            
            // Set origin position
            originX = currentX;
            originY = currentY;
            originZ = currentZ;
            
            // Reset velocity
            velocityX = 0;
            velocityY = 0;
            velocityZ = 0;
            
            // Start tracking
            tracking = true;
            lastTimestamp = performance.now();
            
            // Initial position update
            updatePositionDisplay();
        }

        // Initialize the application
        async function initialize() {
            const cameraAvailable = await setupCamera();
            if (cameraAvailable) {
                setupSensors();
                startBtn.addEventListener('click', startTracking);
            } else {
                // If camera is not available, try to use sensors only
                setupSensors();
                startBtn.textContent = 'Start Tracking (No Camera)';
                startBtn.addEventListener('click', startTracking);
            }
            initializing = false;
        }

        // Start initialization when page loads
        window.addEventListener('load', initialize);
    </script>
</body>
</html>
